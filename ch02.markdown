---
layout: book
title: "A Tour of the Dart Language"
subsite: "Dart Up and Running"
description: "Read Chapter 2, A Tour of the Dart Language of Dart (from Dart: Up and Running, published by O'Reilly)."
prev-chapter: ch01.html
prev-chapter-title: "Quick Start"
next-chapter: ch03.html
next-chapter-title: "Library Tour"
---

{% include toc.html %}
{% include book-nav.html %}

# {{ page.title }}

Ce chapitre vous montre comment utiliser les fonctionnalités majeures de Dart, des variables
et opérateurs jusqu'aux classes et bibliothèques, en supposant que vous savez
déjà programmer dans une autre langage.

<aside class="alert alert-info" markdown="1">
**Note:**
Pour essayer les fonctionnalités, créez un projet en ligne de commande
avec le Dart Editor, comme décrit ci dessous:
[Up and running](ch01.html#up-and-running).
</aside>

Consultez les [spécifications Dart](/docs/spec/) lorsque vous souhaitez en
savoir plus sur une des fonctionnalités du langages.


## Un programme Dart simple {#a-basic-dart-program}

Le programme suivant utilise quelques unes des fonctionnalités de base de Dart :

<!-- ch02/basic_dart_program.dart -->
{% prettify dart %}
// Définition d'une fonction.
afficheNombre(num unNombre) {
  print('Le nombre est $unNombre.'); // Affiche dans la console
}

// C’est ici que l’application commence son exécution.
main() {
  var nombre = 42; // Déclare et initialise une variable.
  afficheNombre(nombre); // Appel d'une fonction.
}
{% endprettify %}

Voici ce qu’utilise ce programme et qu’utilisent toutes (ou presque toutes) les applications Dart :

<code>// <em>Ceci est un commentaire.</em> </code>

:   Utilisez // pour indiquer que le reste de la ligne est un commentaire.
    Vous pouvez également utiliser /\* ... \*/. Pour plus de détails, voir
    [Commentaires](#comments).

`num`

:   Un type. Quelques un des autres types natifs sont String, int, and bool.

`42`

:   Un nombre littéral. Les littéraux sont une sorte de constante à la compilation.

`print()`

:   Un moyen pratique d’afficher dans la sortie.

`'...'` (or `"..."`)

:   Une chaine de caratère.

<code>$<em>nomDeVariable</em></code> (ou <code>${<em>expression</em>}</code>)

:   L’interpolation: permet l'évaluation de variables ou d'expressions à l'intérieur d'une chaîne de caractères littérale.
    Pour plus d’informations, Voir
    [Strings](#strings).

`main()`

:   La fonction spéciale, nécessaire et de premier niveau où l’application démarre.
    Pour plus d’information, Voir
    [The main() function](#the-main-function).

`var`

:   Une façon de déclarer une variable sans avoir à préciser son type.

<aside class="alert alert-info" markdown="1">
**Note:**
Notre code suite la convention décrite dans le [Dart Style
Guide.](/articles/style-guide/).
Par exemple, nous utilisons une indentation à deux espaces.
</aside>


## Concepts important {#important-concepts}

Pendant que vous apprenez le langage Dart, gardez ces principes et
concepts en mémoire :

-   Tout ce que vous pouvez placer dans une variable est un *objet*,
    et tout objet est une instance d'une *classe*. Y compris les nombres,
    les fonctions et `null` sont des objets. Tous les objets héritent
    de la classe [Object](http://api.dartlang.org/dart_core/Object.html).

-   Le typage statique (comme `num` dans l'exemple précédent) clarifie
    votre intention et permet aux outils de détecter les erreurs de
    types, mais il reste optionnel. (Pendant que vous debuggez votre
    code, vous pourrez remarquer que les variables dont le type n'a pas
    été spécifié ont un type spécial : `dynamic`.)

-   Dart analyse tout votre code avant de le lancer. Vous pouvez fournir
    des indications à Dart, par exemple, en précisant les types ou les
    constantes de compilation, pour détecter les erreurs ou encore pour
    accélérer l'exécution de votre code.

-   Dart supporte les fonctions de premier niveau (tel que `main()`),
    tout comme elles peuvent être attachées à une classe ou un objet
    (respectivement, *fonctions statiques* et *méthodes d'instance*).
    Vous pouvez aussi créer des fonctions à l'intérieur d'une fonction
    (*fonctions imbriquées* ou *fonctions internes*).

-   De la même façon, Dart supporte les *variables* de premier niveau,
    tout comme elles peuvent être attachées à une classe ou un objet
    (variables statiques et variables d'instance). Les variables
    d'instance sont aussi nommées champs ou propriétés.

-   Contrairement à Java, Dart n'a pas les mots-clés `public`,
    `protected` et `private`. Si un identifiant commence avec un
    souligner (\_), il est privé à sa librairie. Pour plus de détails,
    voir [Librairies et visibilité](#libraries-and-visibility).

-   Les *identifiants* peuvent commencer par une lettre ou \_, suivi de
    n'importe quelle combinaison de ces caractères ou chiffres.

-   Il est parfois important de distinguer *expression* et
    *instruction*, nous allons préciser la différence entre ces deux
    mots.

-   Les outils Dart peuvent rapporter deux types de problèmes : des
    alertes et des erreurs. Les alertes indiquent juste que votre code
    peut ne pas fonctionner, mais n'empêche pas l'exécution de votre
    programme. Une erreur de compilation empêche totalement l'exécution
    de votre programme; une erreur à l'exécution résulte d'une
    [exception](#exceptions) qui est remontée lorsque le code s'exécute.

<ul>
  <li id="runtime-modes" class="no_toc" markdown="1">
  Dart a deux <em id="runtime-modes">modes d'exécution</em> :
  production et checked. Nous recommandons de développer et debugger
  en mode checked, et déployer en mode production.

  *Le mode production* est le mode d'exécution par défaut d'un
  programme Dart, optimisé pour la vitesse. Le mode production ignore
  les [instructions d'assertion](#assert) et le typage statique.

  *Le mode checked* est un mode pour les développeurs, qui aide à
  détecter certaines erreurs de type à l'exécution. Par exemple, si on
  affecte une chaîne de caractères à une variable déclarée comme `num`,
  alors le mode checked lance une exception.
  </li>
</ul>

## Mots clés {#keywords}

Le tableau suivant liste les mots clés que le langage Dart traite spécialement.

{% assign bii = '&nbsp;<sup title="built-in-identifier" alt="built-in-identifier">1</sup>' %}
{% assign lrw = '&nbsp;<sup title="limited reserved word" alt="limited reserved word">2</sup>' %}

| abstract{{bii}}   | continue          | false             | new               | this              |
| as{{bii}}         | default           | final             | null              | throw             |
| assert            | deferred{{bii}}   | finally           | operator{{bii}}   | true              |
| async{{lrw}}      | do                | for               | part{{bii}}       | try               |
| async*{{lrw}}     | dynamic{{bii}}    | get{{bii}}        | rethrow           | typedef{{bii}}    |
| await{{lrw}}      | else              | if                | return            | var               |
| break             | enum              | implements{{bii}} | set{{bii}}        | void              |
| case              | export{{bii}}     | import{{bii}}     | static{{bii}}     | while             |
| catch             | external{{bii}}   | in                | super             | with              |
| class             | extends           | is                | switch            | yield{{lrw}}      |
| const             | factory{{bii}}    | library{{bii}}    | sync*{{lrw}}      | yield*{{lrw}}     |
{:.table .table-striped .nowrap}

<sup>1</sup>  Les mots annotés **1** sont des *identifiants primitifs*.
Evitez d’utiliser les identifants inclus en tant qu’identifiant,
et ne les utilisez jamais en nom de classe ou de type.
Les identifiants inclus existent pour faciliter le portage de JavaScript à Dart.
Par exemple, si du code JavaScript a une variable nommée `factory`,
il n’est pas nécessaire de la renommer lorsque vous portez le code en Dart.

<sup>2</sup> Les mots annotés **2** sont nouveaux,
ces mots réservés sont liés au support de l’asynchronisme
qui a été ajouté après la  sortie de la version 1.0 de Dart.
Vous ne pouvez pas utiliser async, await, ou yield en tant
qu’identifiant dans le corps d’une fonction marquée avec `async`, `async*`, or `sync*`.
Pour plus d’information, voir
[Dart Language Asynchrony Support: Phase 1](/articles/await-async/)
and the [Dart Language Specification](/docs/spec/).

Tous les autres mots de ce tableau sont des <em>mots réservés</em>.
Vous ne pouvez pas utiliser les mots réservés en tant qu’identifiant.


## Variables {#variables}


Ici un exemple de création de variables et d'affectation de valeur:

<!-- ch02/creating_a_variable.dart -->
{% prettify dart %}
var name = 'Bob';
{% endprettify %}

Les variables sont des références. La variable `name` contient une référence
vers une chaine de caractères qui a pour valeur “Bob”.


### Valeur par défaut {#default-value}
{:.no_toc}

Les variables non initialisées ont `null` pour valeur initiale, même les
variables numériques car les nombres sont des objets.

<!-- ch02/numbers_are_objects.dart -->
{% prettify dart %}
int lineCount;
assert(lineCount == null);
// Les variables (même si numériques) sont initialisées à null.
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
L'appel à `assert()` est ignoré en mode production. Par contre en mode vérification,
<code>assert(<em>condition</em>)</code> lance une exception si *condition*
est fausse. Pour plus d'informations, voir la section [Assert](#assert).
</aside>


### Types optionnels {#optional-types}
{:.no_toc}

Vous avez la possibilité d'assigner un type statique à une variable lors de sa déclaration:

<!-- ch02/static_types.dart -->
{% prettify dart %}
String name = 'Bob';
{% endprettify %}

Mettre des types est un bon moyen de spécifier son intention. Les outils comme les
compilateurs et éditeurs peuvent utiliser ces types pour vous aider, en
fournissant de la l'auto-complétion de code ou des alertes préventives sur des
bugs.

<aside class="alert alert-info" markdown="1">
**Note:**
Ce chapitre suit la [convention de code](/articles/style-guide/#type-annotations)
d'utiliser `var` plutôt que des statiques pour des variables locales.
</aside>


### Final et const {#final-and-const}
{:.no_toc}

Si vous n'avez pas l'intention de changer une variable, utiliser `final` ou
`const`, plutôt que `var` ou en complément à un type. Une variable final peut
seulement être affectée une fois; une variable const peut être une constante de
compilation.

Une variable de premier niveau ou de classe déclarée comme `final` est initialisée
à sa première utilisation:

<!-- ch02/final_initialization.dart -->
{% prettify dart %}
final nom = 'Bob';   // Ou: final String nom = 'Bob';
// nom = 'Alice';    // Décommenter cette ligne produit une erreur.
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
L'initialisation paresseuse d'une variable final aide à rendre le démarrage d'une
application plus rapide.
</aside>

Utilisez `const` pour les variables que vous souhaitez utiliser comme constantes de
compilation. Si la variable const est au niveau de la classe, mettez la en
`static const` (les variables d'instances ne peuvent pas être const). Là où vous
déclarez la variable, mettez la valeur en constante de compilation comme
litérale, une variable const, ou le résultat d'une opération arithmétique sur
une constante numérique.

<!-- ch02/const.dart -->
{% prettify dart %}
const bar = 1000000;       // Unité de pression (en dynes/cm2)
const atm = 1.01325 * bar; // Atmosphere standard
{% endprettify %}


## Types natifs {#built-in-types}

Les types suivants sont nativement supportés par le langage Dart :

-   les nombres

-   les chaînes de caractères

-   les booléens

-   les listes (aussi connues comme *tableaux*)

-   les dictionnaires (aussi appelés *tableaux associatifs*)

-   les symboles

Vous pouvez initialiser un objet de n'importe quel de ces types en 
utisant une valeur littérale. Par exemple, `'ceci est une chaîne de 
caractères'` est une chaîne de caractères littérale, et `true` est un 
booléen littéral.

Comme toute variable en Dart fait référence à un objet, c'est-à-dire,
à une instance d'une *classe*, vous pouvez utiliser des *constructeurs*
pour initialiser ces variables. Certains de ces types natifs ont leurs 
propres constructeurs. Par exemple, vous pouvez utiliser le constructeur
`Map()` pour créer un dictionnaire, en utilisant le code tel que 
`new Map()`.


### Nombres {#numbers}
{:.no_toc}

Il existe deux types de nombre en Dart :

[`int`](http://api.dartlang.org/dart_core/int.html)

:   Les valeurs entières, qui doivent être généralement comprise entre
    -2<sup>53</sup> et 2<sup>53</sup>

[`double`](http://api.dartlang.org/dart_core/double.html)

:   Les nombres à virgule flottante 64-bit (double précision), tel que
    spécifié dans le standart IEEE 754

Les deux types `int` et `double` sont des sous-types de 
[`num`.](http://api.dartlang.org/dart_core/num.html) Le type num 
inclut des opérateurs de base tel que +, -, /, et \*, mais aussi les 
opérateurs bit à bit tel que \>\>. Vous trouverez aussi dans le type 
num, `abs()`,` ceil()`, et `floor()`, parmi d'autres méthodes. Si num 
et ses sous-types n'ont pas ce que vous recherchez, la librairie
[Math](http://api.dartlang.org/dart_math.html) peut vous aider.

<aside class="alert alert-warning" markdown="1">
**Attention :**
Actuellement, les nombres entiers en dehors de l'intervalle
-2<sup>53</sup> et 2<sup>53</sup> se comporte différement dans le 
JavaScript généré à partir du code Dart comparé au même code Dart 
tournant sous la machine virtuelle Dart. La raison est que Dart a été 
spécifié pour avoir des entiers multiprécisions, ce qui n'est pas le 
cas de JavaScript.
Voir [issue 1533](http://dartbug.com/1533) pour plus de détails.
</aside>

Les entiers sont des nombres sans décimale. Voici quelques exemples 
de nombres entiers littéraux :

<!-- ch02/integer_literals.dart -->
{% prettify dart %}
var x = 1;
var hex = 0xDEADBEEF;
var grosEntier = 346534658346524376592384765923749587398457294759347029438709349347;
{% endprettify %}

Si un nombre inclut une décimale, c'est un double. Voici quelques exemples 
de nombres réels littéraux :

<!-- ch02/double_literals.dart -->
{% prettify dart %}
var y = 1.1;
var dixPuissance = 1.42e5;
{% endprettify %}

Voici comment transformer une chaîne de caractères en nombre, ou vice 
versa :

<!-- ch02/number_conversion.dart -->
{% prettify dart %}
// String -> int
var un = int.parse('1');
assert(un == 1);

// String -> double
var unVirguleUn = double.parse('1.1');
assert(unVirguleUn == 1.1);

// int -> String
String unEnString = 1.toString();
assert(unEnString == '1');

// double -> String
String piEnString = 3.14159.toStringAsFixed(2);
assert(piEnString == '3.14');
{% endprettify %}

Le type int définit le traditionnel décalage de bit (\<\<, \>\>), les 
opérateurs ET (&), et OU (|). Par exemple :

<!-- ch02/bit_shifting.dart -->
{% prettify dart %}
assert((3 << 1) == 6);  // 0011 << 1 == 0110
assert((3 >> 1) == 1);  // 0011 >> 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111
{% endprettify %}


### Chaînes de caractères {#strings}
{:.no_toc}

Une chaîne de caractères en Dart est une suite de codes UTF-16. Vous 
pouvez utiliser des guillemets simples ou des guillemets doubles pour 
créer une chaîne de caractères :

<!-- ch02/quoting.dart -->
{% prettify dart %}
var s1 = 'Les guillemets simples fonctionnent pour les chaînes de caractères littérales.';
var s2 = "Les guillemets doubles fonctionnent tout aussi bien.";
var s3 = 'C\'est facile d\'échapper les délimiteurs d\'une chaîne de caractères.';
var s4 = "C'est encore plus facile d'utiliser l'autre délimiteur.";
{% endprettify %}

Vous pouvez mettre la valeur d'une expression à l'intérieur d'une 
chaine de caractères en utilisant `${`*`expression`*`}`. Si 
l'expression est un identifiant, vous pouvez omettre les {}. Pour 
obtenir la chaîne de caractères correspondant à un objet, Dart appelle
la méthode `toString()` de l'objet.

<!-- ch02/string_interpolation.dart -->
{% prettify dart %}
var s = 'interpolation';

assert("Dart a l'$s, ce qui est très pratique." ==
       "Dart a l'interpolation, ce qui est très pratique.");
assert("Le même en majuscule. L'${s.toUpperCase()} est très pratique !" ==
       "Le même en majuscule. L'INTERPOLATION est très pratique !");
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
L'opérateur `==` teste si deux objets sont équivalents. Deux
chaînes de caractères sont équivalentes s'elles contiennent la même 
suite de codes de caractère.
</aside>

Vous pouvez concatener des chaînes de caractères en utilisant des 
chaînes littérales adjacentes ou l'opérateur `+` :

<!-- adjacent_string_literals.dart -->
{% prettify dart %}
var s1 = 'La concatenation ' ' de chaînes de caractères'
         " fonctionne même avec des retours à la ligne.";
assert(s1 == 'La concatenation de chaînes de caractères fonctionne même avec des retours à la ligne.');

var s2 = "L'opérateur plus "
         + 'fonctionne également.';
assert(s2 == "L'opérateur plus fonctionne également.");
{% endprettify %}

Une autre façon de créer des chaînes de caractères multiligne est 
d'utiliser un triplet de guillements qu'ils soient simple ou double :

<!-- ch02/triple_quotes.dart -->
{% prettify dart %}
var s1 = '''
Vous pouvez créer
des chaînes de caractères multiligne comme celle-ci.
''';

var s2 = """Celle-là est aussi une
chaîne de caractères multiligne.""";
{% endprettify %}

Vous pouvez créer une chaîne de caractères “brute” en la préfixant 
avec `r` :

<!-- ch02/raw_strings.dart -->
{% prettify dart %}
var s = r"Dans une chaîne de caractères brute, même \n n'est pas spécial.";
{% endprettify %}

Vous pouvez utiliser l'échappement Unicode dans une chaîne de caractères :

<!-- ch02/quoting.dart -->
{% prettify dart %}
print("L'échapement Unicode fonctionne : \u2665"); // L'échapement Unicode fonctionne : [heart]
{% endprettify %}

Pour plus d'information sur comment utiliser les chaînes de caractères, voir
[Chaînes de caractères et expressions régulières](ch03.html#strings-and-regular-expressions).


### Booléens {#booleans}
{:.no_toc}

Pour représenter les valeurs booléennes, Dart a un type nommé `bool`. 
Seulement deux objets ont le type booléen: les valeurs littérales 
`true` et `false`, respectivement vrai et faux.

Lorsque Dart s'attend à une valeur booléenne, seulement la valeur `true`
est considérée comme vraie. Toutes les autres valeurs sont considérées
comme fausses. Contrairement à JavaScript, les valeurs telles que `1`, 
`"uneChaineDeCaractères"`, et `unObjet` sont toutes considérées comme 
fausses.

Par exemple, considérons le code suivant qui est valide en JavaScript et
en Dart :

<!-- ch02/strictly_booleans.dart -->
{% prettify dart %}
var nom = 'Bob';
if (nom) {
  print('Tu as un nom !'); // S'affiche en JavaScript, mais pas en Dart.
}
{% endprettify %}

Si vous lancez ce code en JavaScript, il affiche “Tu as un nom !” car 
`nom` est un objet non null. Par contre, en Dart tournant dans un mode 
production, le code précédent n'affiche rien car `nom` est converti 
en `false` (car `nom != true`). En Dart tournant dans un mode de 
vérification le code précédent lance une exception car la variable `nom`
n'est pas un booléen.

Voici un autre exemple de code qui se comporte différement entre 
JavaScript et Dart :

<!-- ch02/if_one.dart -->
{% prettify dart %}
if (1) {
  print('JavaScript affiche cette ligne car il pense que 1 est vrai.');
} else {
  print('Dart en mode production affiche cette ligne.');
  // Cependant, en mode vérification, if (1) lance une exception.
}
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
Les deux examples précédents fonctionnent seulement en mode production, 
pas en mode vérification. En mode vérification, une exception est lancée
si un non-booléen est utilisé alors qu'une valeur booléenne est attendue.
</aside>

Le traitement des booléens en Dart a été conçu de façon à éviter des 
comportements étranges qui peuvent arriver lorsque de nombreuses valeurs
sont considérées comme vraie. Ce qui signifie pour vous c'est que, 
au lieu d'utiliser du code comme 
<code>if (<em>valeurNonBooleene</em>)</code>, il faut plutôt 
vérifier explicitement les valeurs. Par exemple :

<!-- ch02/empty_string.dart -->
{% prettify dart %}
// Vérifie que la chaîne de caractères est vide.
var nom = '';
assert(nom.isEmpty);

// Vérifie si la valeur est zero.
var pointDeVie = 0;
assert(pointDeVie <= 0);

// Vérifie si la valeur est null.
var unicorne;
assert(unicorne == null);

// Vérifie si la valeur n'est pas un nombre.
var jeVoulaisLeFaire = 0 / 0;
assert(jeVoulaisLeFaire.isNaN);
{% endprettify %}


### Listes {#lists}
{:.no_toc}

Peut-être la collection la plus commune dans presque tous les langages
de programmation est le *tableau*, ou un groupe ordonné d'objets. Dans
Dart, les tableaux sont des objets 
[List](http://api.dartlang.org/dart_core/List.html), donc nous les 
appelons juste *listes*.

Les listes littérales Dart ressemblent aux tableaux littéraux de 
JavaScript. Voici un exemple d'une liste Dart :

<!-- ch02/list_literal.dart -->
{% prettify dart %}
var liste = [1, 2, 3];
{% endprettify %}

Les listes utilisent une indexation à partir de zero, c'est-à-dire que
l'index 0 est l'index du premier élément et `list.length - 1` est 
l'index du dernier élément. Vous pouvez obtenir la longueur de la liste
et faire référence aux éléments de la liste comme vous le feriez en 
JavaScript :

<!-- ch02/list_indexing.dart -->
{% prettify dart %}
var liste = [1, 2, 3];
assert(liste.length == 3);
assert(liste[1] == 2);
{% endprettify %}

Le type List a plein de méthodes pratiques pour manipuler les listes.
Pour plus d'information sur les listes, voir [Generiques](#generics) et
[Collections](ch03.html#collections).


### Dictionnaires {#maps}
{:.no_toc}

En général, un dictionnaire est un objet qui associe des clés et des 
valeurs. Clés et valeurs peuvent être de n'importe quel type d'objet.
Chaque *clé* n'apparait qu'une seule fois, mais vous pouvez utiliser 
une même *valeur* plusieurs fois. Le support des dictionnaires par Dart
est fait grâce aux dictionnaires en valeurs littérales et au type 
[Map](http://api.dartlang.org/dart_core/Map.html).

Voici quelques exemples simples de dictionnaire en Dart, crées en 
utilisant des valeurs littérales :

<!-- ch02/map_literal.dart -->
{% prettify dart %}
var cadeaux = {
// Clés          Valeurs
  'premier'   : 'perdrix',
  'deuxième'  : 'tourterelle',
  'cinquième' : 'faisan'
};

var gazNobles = {
// Clés  Valeurs
  2 :   'hélium',
  10:   'néon',
  18:   'argon',
};
{% endprettify %}

Vous pouvez créer les mêmes objets en utilisant le constructeur Map :

<!-- ch02/map_constructor.dart -->
{% prettify dart %}
var cadeaux = new Map();
cadeaux['premier'] = 'perdrix';
cadeaux['deuxième'] = 'tourterelle';
cadeaux['cinquième'] = 'anneaux d\'or';

var gazNobles = new Map();
gazNobles[2] = 'hélium';
gazNobles[10] = 'néon';
gazNobles[18] = 'argon';
{% endprettify %}

Ajoutez une nouvelle paire clé-valeur à un dictionnaire existant comme
vous le feriez en JavaScript :

<!-- ch02/map_add_item.dart -->
{% prettify dart %}
var cadeaux = {'premier': 'perdrix'};
cadeaux['quatrième'] = 'merles noirs'; // Ajoute une paire clé-valeur
{% endprettify %}

Récupérez une valeur d'un dictionnaire de la même façon que vous le 
feriez en JavaScript :

<!-- ch02/map_retrieve_item.dart -->
{% prettify dart %}
var cadeaux = {'premier': 'perdrix'};
assert(cadeaux['premier'] == 'perdrix');
{% endprettify %}

Si vous cherchez une clé qui n'est pas dans le dictionnaire, vous 
obtenez un null en retour :

<!-- ch02/map_missing_key.dart -->
{% prettify dart %}
var cadeaux = {'premier': 'perdrix'};
assert(cadeaux['cinquième'] == null);
{% endprettify %}

Utilisez `.length` pour obtenir le nombre de paires clé-valeur dans le 
dictionnaire :

<!-- ch02/map_length.dart -->
{% prettify dart %}
var cadeaux = {'premier': 'perdrix'};
cadeaux['quatrième'] = 'merles noirs';
assert(cadeaux.length == 2);
{% endprettify %}

Pour plus d'information sur les dictionnaires, voir
[Generics](#generics) et
[Maps](ch03.html#maps).


### Symboles {#symbols}
{:.no_toc}

Un objet [Symbol](http://api.dartlang.org/dart_core/Symbol.html) 
représente un opérateur ou un identifiant déclaré dans un programme 
Dart. Vous n'aurait peut être jamais le besoin d'utiliser les symboles,
mais ils sont indispensables pour les APIs qui font référence à un 
identifiant par son nom, car la minification change les noms des 
identifiants mais pas ceux des symboles.

Pour obtenir le symbole pour un identifiant, utilisez un symbole 
littéral, qui est juste un `#` suivi de l'identifiant :

<!-- ch02/symbols.dart -->
{% prettify dart %}
#radix  // Le symbole littéral pour l'identifiant nommé 'radix'.
#bar    // Le symbole littéral pour l'identifiant nommé 'bar'.
{% endprettify %}

Pour plus d'information sur les symboles, voir
[dart:mirrors - reflection](ch03.html#dartmirrors---reflection).


## Functions {#functions}

Here’s an example of implementing a function:

<!-- ch02/function_types.dart -->
{% prettify dart %}
void printNumber(num number) {
  print('The number is $number.');
}
{% endprettify %}

Although the style guide recommends specifying the parameter and return
types, you don’t have to:

<!-- ch02/function_omitting_types.dart -->
{% prettify dart %}
printNumber(number) { // Omitting types is OK.
  print('The number is $number.');
}
{% endprettify %}

For functions that contain just one expression, you can use a shorthand
syntax:

<!-- ch02/function_shorthand.dart -->
{% prettify dart %}
printNumber(number) => print('The number is $number.');
{% endprettify %}

The <code>=> <em>expr</em>;</code> syntax is a shorthand for
<code>{ return <em>expr</em>;}</code>. In the `printNumber()` function, the expression is the
call to the top-level `print()` function.

<aside class="alert alert-info" markdown="1">
**Note:**
Only an *expression*—not a *statement*—can appear between the arrow
(=\>) and the semicolon (;). For example, you can’t put an [if
statement](#if-and-else) there, but you can use a [conditional (`?:`)
expression](#other-operators).
</aside>

You can use types with =\>, although the convention is not to do so:

<!-- ch02/function_calling.dart -->
{% prettify dart %}
printNumber(num number) => print('The number is $number.');
{% endprettify %}

Here’s an example of calling a function:

<!-- ch02/function_calling.dart -->
{% prettify dart %}
printNumber(123);
{% endprettify %}

A function can have two types of parameters: required and optional. The
required parameters are listed first, followed by any optional
parameters.


### Optional parameters {#optional-parameters}
{:.no_toc}

Optional parameters can be either positional or named, but not both.

Both kinds of optional parameter can have default values. The default
values must be compile-time constants such as literals. If no default
value is provided, the value is `null`.

#### Optional named parameters {#optional-named-parameters}
{:.no_toc}

When calling a function, you can specify named parameters using
<code><em>paramName</em>: <em>value</em></code>. For example:

<!-- ch02/use_named_parameters.dart -->
{% prettify dart %}
enableFlags(bold: true, hidden: false);
{% endprettify %}

When defining a function, use
<code>{<em>param1</em>, <em>param2</em>, …}</code>
to specify named parameters:

<!-- ch02/specify_named_parameters.dart -->
{% prettify dart %}
/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}
{% endprettify %}

Use a colon (`:`) to specify default values:

<!-- ch02/specify_default_values.dart -->
{% prettify dart %}
/// Sets the [bold] and [hidden] flags to the values you specify,
/// defaulting to false.
enableFlags({bool bold: false, bool hidden: false}) {
  // ...
}

enableFlags(bold: true); // bold will be true; hidden will be false.
{% endprettify %}

#### Optional positional parameters {#optional-positional-parameters}
{:.no_toc}

Wrapping a set of function parameters in `[]` marks them as optional
positional parameters:

<!-- ch02/optional_positional_parameters.dart -->
{% prettify dart %}
String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
{% endprettify %}

Here’s an example of calling this function without the optional
parameter:

<!-- ch02/optional_positional_parameters.dart -->
{% prettify dart %}
assert(say('Bob', 'Howdy') == 'Bob says Howdy');
{% endprettify %}

And here’s an example of calling this function with the third parameter:

<!-- ch02/optional_positional_parameters.dart -->
{% prettify dart %}
assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');
{% endprettify %}

Use `=` to specify default values:

<!-- ch02/optional_positional_parameter_default.dart -->
{% prettify dart %}
String say(String from, String msg,
    [String device = 'carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');
{% endprettify %}


### The main() function {#the-main-function}
{:.no_toc}

Every app must have a top-level `main()` function, which serves as the
entrypoint to the app. The `main()` function returns `void` and has an
optional `List<String>` parameter for arguments.

Here's an example of the `main()` function for a web app:

<!-- from Dart Editor's default web app -->
{% prettify dart %}
void main() {
  querySelector("#sample_text_id")
    ..text = "Click me!"
    ..onClick.listen(reverseText);
}
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
The `..` operator in the preceding code is a cascade operator, which
allows you to perform multiple operations on the members of a single
object. You'll find out more in [Classes](#classes).
</aside>

Here's an example of the `main()` function for a command-line app that
takes arguments:

<!-- ch02/args.dart -->
{% prettify dart %}
// Run the app like this: dart args.dart 1 test
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
{% endprettify %}

You can use the [args library](https://pub.dartlang.org/packages/args) to
define and parse command-line arguments.


### Functions as first-class objects {#functions-as-first-class-objects}
{:.no_toc}

You can pass a function as a parameter to another function. For example:

<!-- from ch02/function_as_parameter.dart -->
{% prettify dart %}
printElement(element) {
  print(element);
}

var list = [1, 2, 3];
list.forEach(printElement); // Pass printElement as a parameter.
{% endprettify %}

You can also assign a function to a variable, such as:

<!-- from ch02/function_as_variable.dart -->
{% prettify dart %}
var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');
{% endprettify %}


### Lexical scope {#lexical-scope}
{:.no_toc}

Dart is a lexically scoped language, which means that the scope of
variables is determined statically, simply by the layout of the code.
You can “follow the curly braces outwards” to see if a variable is in
scope.

Here is an example of nested functions with variables at each scope
level:

<!-- ch02/nested_functions.dart -->
{% prettify dart %}
var topLevel = true;

main() {
  var insideMain = true;

  myFunction() {
    var insideFunction = true;

    nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}
{% endprettify %}

Notice how `nestedFunction()` can use variables from every level, all
the way up to the top level.


### Lexical closures {#lexical-closures}
{:.no_toc}

A *closure* is a function object that has access to variables in its
lexical scope, even when the function is used outside of its original
scope.

Functions can close over variables defined in surrounding scopes. In the
following example, `adder()` captures the variable `addBy`. Wherever the
returned function goes, it remembers `addBy`.

<!-- ch02/function_closure.dart -->
{% prettify dart %}
/// Returns a function that adds [addBy] to a number.
Function makeAdder(num addBy) {
  adder(num i) {
    return addBy + i;
  }
  return adder;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
{% endprettify %}


### Testing functions for equality {#testing-functions-for-equality}
{:.no_toc}

Here's an example of testing top-level functions, static methods, and
instance methods for equality:

<!-- ch02/function_equality_2.dart -->
{% prettify dart %}
foo() {}               // A top-level function

class SomeClass {
  static void bar() {} // A static method
  void baz() {}        // An instance method
}

main() {
  var x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = new A(); // Instance #1 of A
  var w = new A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they're equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they're unequal.
  assert(v.baz != w.baz);
}
{% endprettify %}


### Return values {#return-values}
{:.no_toc}

All functions return a value. If no return value is specified, the
statement `return null;` is implicitly appended to the function body.


## Opérateurs {#operators}

Les opérateurs définis par Dart sont présentés dans le tableau suivant.
Vous pouvez surcharger certains de ces opérateurs, comme décrit dans
[Surcharge d'opérateurs](#overridable-operators).

|--------------------------+------------------------------------------------|
|Description               | Opérateur                                       |
|--------------------------|------------------------------------------------|
| post-fixé unaire           | <code><em>expr</em>++</code>    <code><em>expr</em>--</code>    `()`    `[]`    `.`             |
| pre-fixé unaire            | <code>-<em>expr</em></code>    <code>!<em>expr</em></code>    <code>~<em>expr</em></code>    <code>++<em>expr</em></code>    <code>--<em>expr</em></code>   |
| multificatif           | `*`    `/`    `%`    `~/`                      |
| additif                 | `+`    `-`                                     |
| décalage                    | `<<`    `>>`                                   |
| ET binaire              | `&`                                            |
| OU exclusif binaire              | `^`                                            |
| OU binaire               | `|`                                            |
| comparateur&nbsp;et&nbsp;test de&nbsp;type | `>=`    `>`    `<=`    `<`    `as`    `is`    `is!`      |
| égalité                 | `==`    `!=`                                   |
| ET logique              | `&&`                                           |
| OU logique               | `||`                                           |
| conditionnel              | <code><em>expr1</em> ? <em>expr2</em> : <em>expr3</em></code>        |
| cascade                  | `..`                                           |
| assignation               | `=`    `*=`    `/=`    `~/=`    `%=`    `+=`    `-=`    `<<=`    `>>=`    `&=`    `^=`    `|=`                 |
{:.table .table-striped}

Quand vous utilisez les opérateurs, vous créez des expressions. Voici quelques exemples d'expressions utilisant des opérateurs :

<!-- TODO: write test for this -->
{% prettify dart %}
a++
a + b
a = b
a == b
a ? b: c
a is T
{% endprettify %}

Dans le précédent tableau des opérateurs, chaque opérateur a une plus haute priorité que les opérateurs dans des lignes suivantes.

Par exemple, l'opérateur multiplicatif `%` a une priorité plus importante que (et de ce fait s'éxecute avant) l'opérateur `==`, qui a lui même une priorité plus importante que l'opérateur logique AND `&&`.
Cette priorié signifie que les deux lignes de code suivantes s'exécutent de la même façon :

<!-- ch02/precedence.dart -->
{% prettify dart %}
// 1: Les parenthèses améliorent la lisibilité.
if ((n % i == 0) && (d % i == 0))

// 2: Plus difficile à lire mais identique.
if (n % i == 0 && d % i == 0)
{% endprettify %}

<aside class="alert alert-warning" markdown="1">
**Attention:**
Pour les opérateurs qui travaillent sur deux opérandes, c'est l'opérande la plus à gauche qui détermine la version de l'opérateur utilisé. Par exemple, si vous avez un objet Vecteur et un objet Point, `unVecteur + unPoint` utilise l'opérateur + de l'objet Vecteur.
</aside>


### Les opérateurs arithmétiques {#arithmetic-operators}
{:.no_toc}

Dart supporte les opérateurs arithmétiques usuels, comme montré dans le tableau suivant.

|-----------------------------+-------------------------------------------|
| Operateur                    | Signification                                   |
|-----------------------------+-------------------------------------------|
| `+`                         | Ajoute
| `–`                         | Soustrait
| <code>-<em>expr</em></code> | Moins unaire, aussi connu comme négation (inverse le signe de l'expression)
| `*`                         | Multiplie
| `/`                         | Divise
| `~/`                        | Divise, retourne un résultat entier
| `%`                         | Donne le reste d'une division entière (modulo)
{:.table .table-striped}

Example:

<!-- ch02/arithmetic_operators.dart -->
{% prettify dart %}
assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5);   // Le résultat est un double
assert(5 ~/ 2 == 2);    // Le résultat est un entier
assert(5 % 2 == 1);     // Reste

print('5/2 = ${5~/2} reste ${5%2}'); // 5/2 = 2 reste 1
{% endprettify %}

Dart supporte également les opérateurs de pré et post incrémentation et décrémentation

|-----------------------------+-------------------------------------------|
| Opérateur                    | Signification                                   |
|-----------------------------+-------------------------------------------|
| <code>++<em>var</em></code> | <code><em>var</em> = <em>var</em> + 1</code> (la valeur de l'expression est <code><em>var</em> + 1</code>)
| <code><em>var</em>++</code> | <code><em>var</em> = <em>var</em> + 1</code> (la valeur de l'expression est <code><em>var</em></code>)
| <code>--<em>var</em></code> | <code><em>var</em> = <em>var</em> – 1</code> (la valeur de l'expression est <code><em>var</em> – 1</code>)
| <code><em>var</em>--</code> | <code><em>var</em> = <em>var</em> – 1</code> (la valeur de l'expression est <code><em>var</em></code>)
{:.table .table-striped}

Exemple:

<!-- ch02/op_increment_decrement.dart -->
{% prettify dart %}
var a, b;

a = 0;
b = ++a;        // Incrémente a avant d'attribuer la valeur à b.
assert(a == b); // 1 == 1

a = 0;
b = a++;        // Incrémente a après avoir attribué sa valeur à b.
assert(a != b); // 1 != 0

a = 0;
b = --a;        // Decrémente a avant d'attribuer sa valeur à b.
assert(a == b); // -1 == -1

a = 0;
b = a--;        // Decrémente a après avoir attribué sa valeur à b.
assert(a != b); // -1 != 0
{% endprettify %}


### Opérateurs d'égalité et de comparaison {#equality-and-relational-operators}
{:.no_toc}

Le tableau suivant liste les significations des opérateurs d'égalité et de comparaison.

|-----------+-------------------------------------------|
| Opérateur | Signification                             |
|-----------+-------------------------------------------|
| `==`      |       Egal; voir plus bas
| `!=`      |       Différent
| `>`       |       Plus grand que
| `<`       |       Plus petit que
| `>=`      |       Plus grand ou égal
| `<=`      |       Plus petit ou égal
{:.table .table-striped}

Pour tester si deux objets x et y sont identiques, utilisez l'opérateur `==`. (Dans les rares cas où vous avez besoin de savoir si deux objets sont éxactement le même, utilisez la fonction
[identical()](https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-core#id_identical) à la place.) Voici comment fonctionne l'opérateur `==`:

1.  Si *x* ou *y* est nul, renvoie vrai si les deux sont nuls, et faux si seulement l'un d'eux est nul.

2.  Retourne le résultat de l'invocation
    <code><em>x</em>.==(<em>y</em>)</code>. (C'est ça, les opérateurs tels que `==` sont des méthodes invoquées sur leur premier opérande. Vous pouvez surcharger grand nombre de ces opérateurs, y compris `==`, comme vous pouvez le voir dans
    [Surcharge d'opérateurs](#overridable-operators).)

Voilà un exemple d'utilisation de chacun des opérateurs d'égalité et de comparaison :

<!-- ch02/op_equality.dart -->
{% prettify dart %}
assert(2 == 2);
assert(2 != 3);
assert(3 > 2);
assert(2 < 3);
assert(3 >= 3);
assert(2 <= 3);
{% endprettify %}


### Opérateurs de test sur les types {#type-test-operators}
{:.no_toc}

Les opérateurs `as`, `is`, and `is!` sont très utiles pour tester les types durant l'éxecution.

|-----------+-------------------------------------------|
| Opérateur| Signification                             |
|-----------+-------------------------------------------|
| `as`      | Conversion de type
| `is`      | Vrai si l'objet a le même type
| `is!`     | Faux si l'objet n'a pas le même type
{:.table .table-striped}

Le résultat de `obj is T` est vrai si `obj` implémente l'interface précisée par `T`. Par exemple, `obj is Object` est toujours vrai.

Utilisez l'opérateur `as` pour convertir un objet dans un type spécifique. En général, vous devez l'utiliser comme raccourci pour un test `is` sur un objet suivi d'une expression utilisant cet objet. Par exemple, dans le code suivant :

<!-- ch02/op_as.dart -->
{% prettify dart %}
if (emp is Person) { // Vérification de type
  emp.firstName = 'Bob';
}
{% endprettify %}

Vous pouvez simplifier le code en utilisant l'opérateur `as` :

<!-- ch02/op_increment_decrement.dart -->
{% prettify dart %}
(emp as Person).firstName = 'Bob';
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
Le code n'est pas équivalent. Si `emp` est nul ou n'est pas une instance de Person, le premier exemple (avec `is`) ne fait rien; le second (avec `as`) lève une exception.
</aside>


### Opérateurs d'assignation {#assignment-operators}
{:.no_toc}

Comme nous l'avons déjà vu, vous pouvez assigner des valeurs en utilisant l'opérateur `=`.
Vous pouvez également utiliser des opérateurs composés tels que `+=`, qui combine une opération
avec une assignation.

| `=`  | `–=` | `/=`  | `%=`  | `>>=` | `^=`
| `+=` | `*=` | `~/=` | `<<=` | `&=`  | `|=`
{:.table}

Voici comment fonctionnent les opérateurs d'assignation :

|-----------+----------------------+------------------------|
|           | Assignation composée | Expression équivalente |
|-----------+----------------------+------------------------|
|**Pour un opérateur <em>op</em>:** | <code>a <em>op</em>= b</code> | <code>a = a <em>op</em> b</code>
|**Exemple:**                     |`a += b`                       | `a = a + b`
{:.table}

L'exemple suivant utilise à la fois une assignation et une assignation composeé :

<!-- ch02/op_assign.dart -->
{% prettify dart %}
var a = 2;           // Assignation utilisant =
a *= 3;              // Assignation et multiplication : a = a * 3
assert(a == 6);
{% endprettify %}


### Opérateurs logiques {#logical-operators}
{:.no_toc}

Vous pouvez inverser ou combiner des expressions booléenes en utilisant des opérateurs
logiques.

|-----------------------------+-------------------------------------------|
| Operateur                   | Signification                             |
|-----------------------------+-------------------------------------------|
| <code>!<em>expr</em></code> | Inverse l'expression qui le suit (change faux en vrai, et vice versa)
| `||`                        | OU logique
| `&&`                        | ET logique
{:.table .table-striped}

Voici un exemple d'utilisation des opérateurs logiques :

<!-- ch02/op_logical.dart -->
{% prettify dart %}
if (!done && (col == 0 || col == 3)) {
  // ...Fait quelque chose...
}
{% endprettify %}


### Opérateurs binaires et de décalage de bits {#bitwise-and-shift-operators}
{:.no_toc}

Vous pouvez manipuler individuellement les bits des nombres en Dart. Généralement,
vous utiliserez ces opérateurs binaires et de décalage de bits avec des entiers.

|-----------------------------+-------------------------------------------|
| Opérateur                    | Signification                                   |
|-----------------------------+-------------------------------------------|
| `&`                         | ET
| `|`                         | OU
| `^`                         | OU Exclusif
| <code>~<em>expr</em></code> | Complément binaire à 1 (les 0 deviennent des 1; les 1 deviennent des 0)
| `<<`                        | Décalage à gauche
| `>>`                        | Décalage à droite
{:.table .table-striped}

Voici un exemple d'utilisation des opérateurs binaires et de décalage :

<!-- ch02/op_bitwise.dart -->
{% prettify dart %}
final value = 0x22;
final bitmask = 0x0f;

assert((value & bitmask)  == 0x02);  // ET
assert((value & ~bitmask) == 0x20);  // ET NON
assert((value | bitmask)  == 0x2f);  // OU
assert((value ^ bitmask)  == 0x2d);  // OU Exclusif
assert((value << 4)       == 0x220); // Décalage à gauche
assert((value >> 4)       == 0x02);  // Décalage à droite
{% endprettify %}


### Autres opérateurs {#other-operators}
{:.no_toc}

Il reste quelques opérateurs, vous en avez déjà vu la plupart dans les
autres exemples.

|-----------+-------------------------------------------|
| Opérateur | Nom              |              Signification                                   |
|-----------+-------------------------------------------|
| `()`     | Applique une fonction | Représente un appel de fonction
| `[]`     | Accède à une liste          | Réfère à la valeur dans la liste à l'index spécifié
| <code><em>expr1</em> ? <em>expr2</em> : <em>expr3</em> | Conditionnel | Si _expr1_ est vraie, exécute _expr2_; sinon, exécute _expr3_
| `.`      | Accède un membre        | Réfère à une propriété d'une expression; exemple: `foo.bar` sélectionne la propriété `bar` de l'expression `foo`
| `..`     | Cascade              | Vous permet d'effectuer plusieurs opérations sur les membres d'un même objet; décrit dans [Classes](#classes)
{:.table .table-striped}


##  Structures de contrôle {#control-flow-statements}

Vous pouvez contrôler le flux d'exécution de votre code Dart en utilisant :

-   `if` et `else`

-   boucles `for`

-   boucles `while` et `do`-`while`

-   `break` et `continue`

-   `switch` et `case`

-   `assert`

Vous pouvez aussi modifier le flux en utilisant `try-catch` et `throw`, comme expliqué dans [Exceptions](#exceptions).


### If et else {#if-and-else}
{:.no_toc}

Dart permet les instructions `if` avec des instructions `else` optionnelles, comme le montre l'exemple suivant.
Voir aussi les expressions conditionnelles, qui sont abordées dans [Autres opérateurs](#other-operators).

<!-- ch02/flow_if_else.dart -->
{% prettify dart %}
if (estPluvieux()) {
  vous.prendreImpermeable();
} else if (estNeigeux()) {
  vous.porterBlouson();
} else {
  voiture.conduireDecapotable();
}
{% endprettify %}

N'oubliez pas, contrairement à JavaScript, Dart considère toutes les valeurs autre que `true` comme `false`. 
Voir [Booléens](#booleans) pour plus d'informations.


### Boucles for {#for-loops}
{:.no_toc}

Vous pouvez itérer avec une boucle `for` classique. Par exemple :

<!-- ch02/flow_for_loops.dart -->
{% prettify dart %}
var message = new StringBuffer("Dart est fun");
for (var i = 0; i < 5; i++) {
  message.write('!');
}
{% endprettify %}

Les closures à l'intérieur d'une boucle capturent la valeur de l'index, évitant un piège classique existant en Javascript.
Par exemple, prenons :

<!-- ch02/flow_for_loops.dart -->
{% prettify dart %}
var callbacks = [];
for (var i = 0; i < 2; i++) {
  callbacks.add(() => print(i));
}
callbacks.forEach((c) => c());
{% endprettify %}

La sortie est `0` puis `1` comme voulu. A l'inverse, l'exemple afficherait `2` puis `2` en JavaScript.

Si l'objet sur lequel on itére est un Iterable, vous pouvez utiliser la
<a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-core.Iterable#id_forEach">méthode <code>forEach()</code>.</a>
Utiliser `forEach()` est une bonne solution si vous n'avez pas besoin de connaître la valeur courante du compteur incrémental:

<!-- ch02/flow_for_loops.dart -->
{% prettify dart %}
candidats.forEach((candidat) => candidat.entretien());
{% endprettify %}

Les classes Iterable tel que List et Set autorisent aussi les [itérations](ch03.html#iteration) `for-in` :

<!-- ch02/flow_for_loops.dart -->
{% prettify dart %}
var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}
{% endprettify %}


### While et do-while {#while-and-do-while}
{:.no_toc}

Une boucle `while` évalue la condition avant la boucle :

<!-- ch02/flow_while.dart -->
{% prettify dart %}
while (!estFait()) {
  faireQuelqueChose();
}
{% endprettify %}

Une boucle `do`-`while` évalue la condition *après* la boucle :

<!-- ch02/flow_while.dart -->
{% prettify dart %}
do {
  afficherLigne();
} while (!aLaFinDePage());
{% endprettify %}


### Break et continue {#break-and-continue}
{:.no_toc}

Utiliser `break` pour stopper une boucle :

<!-- ch02/flow_break_continue.dart -->
{% prettify dart %}
while (true) {
  if (extinctionDemandee()) break;
  traitementDesRequetesEntrantes();
}
{% endprettify %}

Utiliser `continue` pour  passer à la prochaine itération de la boucle:

<!-- ch02/flow_break_continue.dart -->
{% prettify dart %}
for (int i = 0; i < candidats.length; i++) {
  var candidat = candidats[i];
  if (candidat.anneeExperience < 5) {
    continue;
  }
  candidat.entretien();
}
{% endprettify %}

Vous pourriez écrire cet exemple différement si vous utilisez un [Iterable](http://api.dartlang.org/dart_core/Iterable.html) 
comme une liste ou un set :

<!-- ch02/flow_break_continue.dart -->
{% prettify dart %}
candidats.where((c) => c.anneeExperience >= 5)
          .forEach((c) => c.entretien());
{% endprettify %}


### Switch et case {#switch-and-case}
{:.no_toc}

Les instructions switch en Dart comparent les entiers, chaines de caractères, 
ou constantes de compilations en utilisant `==. Les objets comparés doivent 
tous être des instances de la même classe (et non pas l'un de ses sous types), 
et la classe doit surcharger `==`.

Chaque `case` non vide prend fin avec une instruction `break`, c'est une règle.
Une autre façon possible de fermer un `case` non vide et une instruction `continue`, 
`throw` ou `return`.

Utiliser une clause `default` pour exécuter du code lorsque aucune clause ne correspond :

<!-- ch02/flow_switch_case.dart -->
{% prettify dart %}
var commande = 'OUVRIR';
switch (commande) {
  case 'FERME':
    executeFerme();
    break;
  case 'EN_ATTENTE':
    executeEnAttente();
    break;
  case 'APPOUVE':
    executeApprouve();
    break;
  case 'INTERDIT':
    executeInterdit();
    break;
  case 'OUVERT':
    executeOuvert();
    break;
  default:
    executeInconnu();
}
{% endprettify %}

L'exemple suivant omet l'instruction `break` de la clause `case`, ce qui génère une erreur :

<!-- ch02/flow_switch_case.dart -->
{% prettify dart %}
var commande = 'OUVERT';
switch (commande) {
  case 'OUVERT':
    executeOuvert();
    // ERREUR: Break manquant provoque une levée d'exception.

  case 'FERME':
    executeFerme();
    break;
}
{% endprettify %}

Cependant, Dart permet une clause `case` vide, autorisant un bloc passant au travers :

<!-- ch02/flow_switch_case.dart -->
{% prettify dart %}
var commande = 'FERME';
switch (commande) {
  case 'FERME': // Cas vide, passe au travers
  case 'FERME_IMMEDIAT':
    // Executé à la fois pour FERME et FERME_IMMEDIAT.
    executeFermeImmediat();
    break;
}
{% endprettify %}

Si vous voulez vraiment passer au travers, vous pouvez utiliser une instruction `continue`
et une étiquette :

<!-- ch02/flow_switch_case.dart -->
{% prettify dart %}
var commande = 'FERME';
switch (commande) {
  case 'CLOSED':
    executeFerme();
    continue maintenantFerme; // Continue l'exécution à l'étiquette maintenantFerme

maintenantFerme:
  case 'MAINTENANT_FERME':
    // Executé à la fois pour FERME et MAINTENANT_FERME.
    executeMaintenantFerme();
    break;
}
{% endprettify %}

Une clause `case` peut avoir des variables locales, qui peuvent être visible seulement
à l'intérieur de la portée de cette clause.


### Assert {#assert}
{:.no_toc}

Utiliser une instruction assert pour empécher l'exécution normale si une condition booléene 
est fausse. Vous pouvez trouver des exemples de déclarations assert
tout au long de cet ouvrage. En voici un de plus :

<!-- ch02/flow_assert.dart -->
{% prettify dart %}
assert(text != null);  // S'assure que la variable a une valeur non nulle.
assert(number < 100);  // S'assure que la valeur est inférieure à 100.
assert(urlString.startsWith('https')); // S'assure que la valeur est une url https.
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
Les instructions assert fonctionnent seulement en mode vérification. Elles n'ont
aucun effet en mode production.
</aside>

A l'intérieur des parenthèses, après `assert`, vous pouvez placer une expression
qui renvoit une valeur booléene ou une fonction. Si la valeur d'une expression ou
de la fonction retournée est vraie, l'assertion réussit et l'exécution continue.
Si elle est fausse, l'assertion échoue et une exception (une 
[AssertionError](http://api.dartlang.org/dart_core/AssertionError.html)) est levée.


## Exceptions {#exceptions}

Votre code Dart peut lever et attraper des exceptions. Les exceptions sont des erreurs indiquant que quelque chose d'inattendu est survenu. Si l'exception n'est pas attrapée, l'isolate qui a levé l'exception est suspendu, et l'isolate et son programme sont interrompus.

Contrairement à Java, toutes les exceptions Dart sont des exceptions incontrôlées.
Les méthodes ne déclarents par quelles exceptions elles sont susceptible de lever, et il ne vous est pas demandé de toutes les attraper.

Dart founit les types
[Exception](http://api.dartlang.org/dart_core/Exception.html) et
[Error](http://api.dartlang.org/docs/continuous/dart_core/Error.html)
, ainsi que de nombreux sous types prédéfinis. Vous pouvez bien entendu définir vos propre exception. Cependant, les programmes Dart peuvent lever n'importe quel objet non nul comme une exception, pas seulement des objets Exception et Error.


### Lever une exception {#throw}
{:.no_toc}

Voici un exemple de comment lever une exception :

<!-- PENDING: NEED TEST FOR THIS -->
{% prettify dart %}
throw new FormatException('au moins une section attendue');
{% endprettify %}

Vous pouvez également lever n'importe quel type d'objet :

<!-- ch02/flow_exceptions.dart -->
{% prettify dart %}
throw 'A cours de lamas!';
{% endprettify %}

Lever une exception étant une expression, vous pouvez lever des exceptions dans les instructions =\>, ainsi que dans tout autre endroit permettant les expressions :

<!-- ch02/flow_exceptions.dart -->
{% prettify dart %}
distanceJusqua(Point autre) => throw new UnimplementedError();
{% endprettify %}


### Attraper une exception {#catch}
{:.no_toc}

Attraper, ou capturer une exception interromp la propagation de l'exception. Attraper une exception vous offre la possibilité de la traiter :

<!-- ch02/flow_exceptions.dart -->
{% prettify dart %}
try {
  eleverPlusDeLamas();
} on PlusDeLamaException {
  acheterPlusDeLamas();
}
{% endprettify %}

Pour traiter du code qui peut lever plus d'un type d'exception,
vous pouvez spécifier de multiples clauses catch. La première clause catch qui correspond au type de l'exception levée traite l'exception. Si la clause catch ne spécifie pas de type, cette clause peut traiter n'importe quel type d'objet levé :

<!-- ch02/flow_exceptions.dart -->
{% prettify dart %}
try {
  eleverPlusDeLamas();
} on PlusDeLamaException { // Une exception spécifique
  acheterPlusDeLamas();
} on Exception catch (e) {  // N'importe quoi d'autre qui est uen exception
  print('Exception inconnue : $e');
} catch (e) {               // Pas de type spécifié, traite tout
  print('Quelque chose de vraiment pas connu : $e');
}
{% endprettify %}

Comme le montre le code précédent, vous pouvez utiliser au choix `on` ou `catch` ou les deux.
Utilisez `on` quand vous avez besoin de spécifier le type de l'exception. Utilisez `catch` lorque traitement de l'exception a besoin de l'objet exception.


### Clause finally {#finally}
{:.no_toc}

Pour s'assurer qu'une partie de code s'exécute qu'une exception est été levée ou pas, utilisez la clause `finally`. Si aucune clause `catch` ne correspond à l'exception, cette dernière est propagée après que la clause `finally` n'ait été lancée :

<!-- ch02/flow_exceptions.dart -->
{% prettify dart %}
try {
  eleverPlusDeLamas();
} finally {
  nettoyerLesStalles();  // Toujours nettoyer, même si une exception est levée.
}
{% endprettify %}

La clause `finally` s'exécute après n'importe quelle clause `catch` :

<!-- ch02/flow_exceptions.dart -->
{% prettify dart %}
try {
  eleverPlusDeLamas();
} catch(e) {
  print('Erreur: $e');  // Traiter l'exception en premier.
} finally {
  nettoyerLesStalles();  // Ensuite nettoyer.
}
{% endprettify %}

Apprenez en davantage en lisant la section  [Exceptions](ch03.html#exceptions).


## Classes {#classes}

Dart est un langage orienté objet avec des classes et un héritage 
à base de mixin. Chaque objet est une instance d'une classe, et toutes
les classes descendent d'[Object.](http://api.dartlang.org/dart_core/Object.html)
L'héritage à base de mixin signifie qu'un corps d'une classe peut être
réutilisé dans un héritage multiple, même si toute classe (excepté pour
Object) a une et une seule classe mère (superclass).

Pour créer un objet, vous pouvez utiliser le mot-clé `new` avec le 
*constructeur* d'une classe. Les noms des constructeurs peuvent être soit
<code><em>NomClasse</em></code> soit
<code><em>NomClasse</em>.<em>identifiant</em></code>. Par exemple :

<!-- ch02/object_classes.dart -->
{% prettify dart %}
var jsonData = JSON.decode('{"x":1, "y":2}');

var p1 = new Point(2, 2);              // Créer un Point en utilisant Point().
var p2 = new Point.fromJson(jsonData); // Créer un Point en utilisant Point.fromJson().
{% endprettify %}

Les objets ont des *membres* constitués de fonctions et de données 
(respectivement *méthodes* et *variables d'instance*). Lorsque vous 
appelez une méthode, vous l'*invoquez* sur un objet : la méthode a accès
aux fonctions et données de l'objet.

Utilisez un point (.) pour faire référence à une variable d'instance 
ou une méthode :

<!-- ch02/object_classes.dart -->
{% prettify dart %}
var p = new Point(2, 2);

p.y = 3;          // Défini la valeur de la variable d'instance y.
assert(p.y == 3); // Obtient la valeur de y.

num distance = p.distanceTo(new Point(4, 4)); // Invoque distanceTo() sur p.
{% endprettify %}

Utilisez l'opérateur en cascade (..) lorsque vous voulez enchainer des 
opérations sur les membres d'un même objet :

<!-- ch02/object_classes.dart -->
{% prettify dart %}
querySelector('#button')
    ..text = 'Cliquez pour confirmer'                    // Récupère un objet. Utilise 
    ..classes.add('important')                           // ses variables d'instance
    ..onClick.listen((e) => window.alert('Confirmé !')); // et ses méthodes.
{% endprettify %}

Certaines classes fournissent des constructeurs de constantes. Pour 
créer une constante à la compilation en utilisant constructeur de 
constantes, utilisez `const` au lieu de `new` :

<!-- ch02/object_classes.dart -->
{% prettify dart %}
var p = const PointImmuable(2, 2);
{% endprettify %}

La construction de deux constantes de compilation identiques résulte 
en une seule et unique instance :

<!-- ch02/object_classes.dart -->
{% prettify dart %}
var a = const PointImmuable(1, 1);
var b = const PointImmuable(1, 1);

assert(identical(a, b)); // Ce sont les mêmes instances !
{% endprettify %}

Les sections suivantes montrent comment implémenter des classes.


### Variables d'instance {#instance-variables}
{:.no_toc}

Voici comment déclarer des variables d'instance :

<!-- ch02/instance_variables.dart -->
{% prettify dart %}
class Point {
  num x;      // Déclare une variable d'instance (x), initialisée à null.
  num y;      // Déclare y, initialisée à null.
  num z = 0;  // Déclare z, initialisée à 0.
}
{% endprettify %}

Toutes les variables d'instance non initialisée ont la valeur `null`.

Toutes les variables d'instance génèrent une méthode *getter* implicite.
Les variables d'instance non-finales génèrent également une méthode 
*setter* implicite. Pour plus de détails, voir 
[Getters et setters](#getters-and-setters).

<!-- ch02/instance_variables.dart -->
{% prettify dart %}
class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Utilise la méthode setter pour x.
  assert(point.x == 4);    // Utilise la méthode getter pour x.
  assert(point.y == null); // Les valeurs par défaut sont nulles.
}
{% endprettify %}

Si vous initialisez une variable d'instance là où elle est déclarée 
(plutôt que dans un constructeur ou dans une méthode), la valeur est 
définie quand l'instance est créée, c'est-à-dire, avant l'exécution du
constructeur et de sa liste d'initialisation.


### Constructors {#constructors}
{:.no_toc}

Declare a constructor by creating a function with the same name as its
class (plus, optionally, an additional identifier as described in
[Named constructors](#named-constructors)).
The most common form of constructor, the generative constructor, creates
a new instance of a class:

<!-- ch02/constructor_long_way.dart -->
{% prettify dart %}
class Point {
  num x;
  num y;

  Point(num x, num y) {
    // There's a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}
{% endprettify %}

The `this` keyword refers to the current instance.

<aside class="alert alert-info" markdown="1">
**Note:**
Use `this` only when there is a name conflict. Otherwise, Dart style
omits the `this`.
</aside>

The pattern of assigning a constructor argument to an instance variable
is so common, Dart has syntactic sugar to make it easy:

<!-- ch02/object_classes.dart -->
{% prettify dart %}
class Point {
  num x;
  num y;

  // Syntactic sugar for setting x and y before the constructor body runs.
  Point(this.x, this.y);
}
{% endprettify %}

#### Default constructors {#default-constructors}
{:.no_toc}

If you don’t declare a constructor, a default constructor is provided
for you. The default constructor has no arguments and invokes the
no-argument constructor in the superclass.

#### Constructors aren’t inherited {#constructors-arent-inherited}
{:.no_toc}

Subclasses don’t inherit constructors from their superclass. A subclass
that declares no constructors has only the default (no argument, no
name) constructor.

#### Named constructors {#named-constructors}
{:.no_toc}

Use a named constructor to implement multiple constructors for a class
or to provide extra clarity:

<!-- ch02/named_constructor.dart -->
{% prettify dart %}
class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Named constructor
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}
{% endprettify %}

Remember that constructors are not inherited, which means that a
superclass’s named constructor is not inherited by a subclass. If you
want a subclass to be created with a named constructor defined in the
superclass, you must implement that constructor in the subclass.

#### Invoking a non-default superclass constructor {#invoking-a-non-default-superclass-constructor}
{:.no_toc}

By default, a constructor in a subclass calls the superclass’s unnamed,
no-argument constructor. If the superclass doesn’t have such a
constructor, then you must manually call one of the constructors in the
superclass. Specify the superclass constructor after a colon (`:`), just
before the constructor body (if any).

<!-- ch02/op_as.dart -->
{% prettify dart %}
class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
}
{% endprettify %}

Because the arguments to the superclass constructor are evaluated before
invoking the constructor, an argument can be an expression such as a
function call:

<!-- ch02/method_then_constructor.dart -->
{% prettify dart %}
class Employee extends Person {
  // ...
  Employee() : super.fromJson(findDefaultData());
}
{% endprettify %}

<aside class="alert alert-warning" markdown="1">
**Warning:**
Arguments to the superclass constructor do not have access to `this`.
For example, arguments can call static methods but not instance
methods.
</aside>


#### Initializer list {#initializer-list}
{:.no_toc}

Besides invoking a superclass constructor, you can also initialize
instance variables before the constructor body runs. Separate
initializers with commas.

<!-- ch02/initializer_list.dart -->
{% prettify dart %}
class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Initializer list sets instance variables before the constructor body runs.
  Point.fromJson(Map jsonMap)
      : x = jsonMap['x'],
        y = jsonMap['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}
{% endprettify %}

<aside class="alert alert-warning" markdown="1">
**Warning:**
The right-hand side of an initializer does not have access to `this`.
</aside>


#### Redirecting constructors {#redirecting-constructors}
{:.no_toc}

Sometimes a constructor’s only purpose is to redirect to another
constructor in the same class. A redirecting constructor’s body is
empty, with the constructor call appearing after a colon (:).

<!-- ch02/along_x_axis.dart -->
{% prettify dart %}
class Point {
  num x;
  num y;

  Point(this.x, this.y);                // The main constructor for this class.
  Point.alongXAxis(num x) : this(x, 0); // Delegates to the main constructor.
}
{% endprettify %}

#### Constant constructors {#constant-constructors}
{:.no_toc}

If your class produces objects that never change, you can make these
objects compile-time constants. To do this, define a `const` constructor
and make sure that all instance variables are `final`.

<!-- ch02/immutable_point.dart -->
{% prettify dart %}
class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}
{% endprettify %}

#### Factory constructors {#factory-constructors}
{:.no_toc}

Use the `factory` keyword when implementing a constructor that doesn’t
always create a new instance of its class. For example, a factory
constructor might return an instance from a cache, or it might return an
instance of a subtype.

The following example demonstrates a factory constructor returning
objects from a cache:

<!-- ch02/factory_constructor.dart -->
{% prettify dart %}
class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
Factory constructors have no access to `this`.
</aside>

To invoke a factory constructor, you use the `new` keyword:

<!-- ch02/factory_constructor.dart -->
{% prettify dart %}
var logger = new Logger('UI');
logger.log('Button clicked');
{% endprettify %}


### Methods {#methods}
{:.no_toc}

Methods are functions that provide behavior for an object.

#### Instance methods {#instance-methods}
{:.no_toc}

Instance methods on objects can access instance variables and `this`.
The `distanceTo()` method in the following sample is an example of an
instance method:

<!-- ch02/distance_to.dart -->
{% prettify dart %}
import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}
{% endprettify %}

#### Getters and setters {#getters-and-setters}
{:.no_toc}

Getters and setters are special methods that provide read and write
access to an object’s properties. Recall that each instance variable has
an implicit getter, plus a setter if appropriate. You can create
additional properties by implementing getters and setters, using the
`get` and `set` keywords:

<!-- ch02/rectangle.dart -->
{% prettify dart %}
class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             => left + width;
      set right(num value)  => left = value - width;
  num get bottom            => top + height;
      set bottom(num value) => top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}
{% endprettify %}

With getters and setters, you can start with instance variables, later
wrapping them with methods, all without changing client code.

<aside class="alert alert-info" markdown="1">
**Note:**
Operators such as increment (++) work in the expected way, whether or
not a getter is explicitly defined. To avoid any unexpected side
effects, the operator calls the getter exactly once, saving its value
in a temporary variable.
</aside>

#### Abstract methods {#abstract-methods}
{:.no_toc}

Instance, getter, and setter methods can be abstract, defining an
interface but leaving its implementation up to other classes. To make a
method abstract, use a semicolon (;) instead of a method body:

<!-- ch02/doer.dart -->
{% prettify dart %}
abstract class Doer {
  // ...Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract here...
  }
}
{% endprettify %}

Calling an abstract method results in a run-time error.

Also see [Abstract classes](#abstract-classes).

#### Overridable operators {#overridable-operators}
{:.no_toc}

You can override the operators shown in the following table.
For example, if you define a
Vector class, you might define a `+` method to add two vectors.

`<`  | `+`  | `|`  | `[]`
`>`  | `/`  | `^`  | `[]=`
`<=` | `~/` | `&`  | `~`
`>=` | `*`  | `<<` | `==`
`–`  | `%`  | `>>`
{:.table}

Here’s an example of a class that overrides the `+` and `-` operators:

<!-- ch02/vector.dart -->
{% prettify dart %}
class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2, 3);
  final w = new Vector(2, 2);

  assert(v.x == 2 && v.y == 3);             // v   == (2,3)
  assert((v + w).x == 4 && (v + w).y == 5); // v+w == (4,5)
  assert((v - w).x == 0 && (v - w).y == 1); // v-w == (0,1)
}
{% endprettify %}

If you override `==`, you should also override Object's `hashCode` getter.
For an example of overriding `==` and `hashCode`, see
[Implementing map keys](ch03.html#implementing-map-keys).

For more information on overriding, in general, see
[Extending a class](#extending-a-class).


### Classes abstraites {#abstract-classes}
{:.no_toc}

Utilisez le modificateur `abstract` pour définir une *classe abstraite*,
c'est-à-dire, une classe qui ne peut pas être instanciée. Les classes 
abstraites sont utiles pour définir des interfaces, souvent avec quelques
implémentations. Si vous voulez que votre classe abstraite apparaisse 
comme instanciable, définissez un [constructeur factory](#factory-constructors).

Les classes abstraites ont souvent des [méthodes abstraites](#abstract-methods).
Voici un exemple de déclaration d'une classe abstraite qui a une méthode 
abstraite :

<!-- ch02/abstract.dart -->
{% prettify dart %}
// Cette classe est déclarée comme abstraite et ne peut pas être instanciée.
abstract class ConteneurAbstrait {
  // ...Définition des constructeurs, champs, méthodes...

  void rafraichirEnfants(); // Abstract method.
}
{% endprettify %}

La classe suivante n'est pas abstraite, et elle peut être instanciée,
même si elle définit une méthode abstraite :

<!-- ch02/abstract.dart -->
{% prettify dart %}
class ConteneurSpecialise extends ConteneurAbstrait {
  // ...Définition d'autres constructeurs, champs, méthodes...

  void rafraichirEnfants() {
    // ...Implémentation de rafraichirEnfants()...
  }

  // La méthode abstraite cause une alerte mais
  // n'empêche pas l'instanciation.
  void faireQuelqueChose();
}
{% endprettify %}


### Implicit interfaces {#implicit-interfaces}
{:.no_toc}

Every class implicitly defines an interface containing all the instance
members of the class and of any interfaces it implements. If you want to
create a class A that supports class B’s API without inheriting B’s
implementation, class A should implement the B interface.

A class implements one or more interfaces by declaring them in an
`implements` clause and then providing the APIs required by the
interfaces. For example:

<!-- ch02/imposter.dart -->
{% prettify dart %}
// A person. The implicit interface contains greet().
class Person {
  final _name;          // In the interface, but visible only in this library,
  Person(this._name);   // Not in the interface, since this is a constructor.
  String greet(who) => 'Hello, $who. I am $_name.'; // In the interface.
}

// An implementation of the Person interface.
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) => 'Hi $who. Do you know who I am?';
}

greetBob(Person person) => person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}
{% endprettify %}

Here’s an example of specifying that a class implements multiple
interfaces:

<!-- ch02/point_interfaces.dart -->
{% prettify dart %}
class Point implements Comparable, Location {
  // ...
}
{% endprettify %}


### Extending a class {#extending-a-class}
{:.no_toc}

Use `extends` to create a subclass, and `super` to refer to the
superclass:

<!-- smart_tv.dart -->
{% prettify dart %}
class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  // ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  // ...
}
{% endprettify %}

Subclasses can override instance methods, getters, and setters. Here’s
an example of overriding the Object class’s `noSuchMethod()` method,
which is called whenever code attempts to use a non-existent method or
instance variable:

<!-- ch02/no_such_method.dart -->
{% prettify dart %}
class A {
  // Unless you override noSuchMethod, using a non-existent member
  // results in a NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('You tried to use a non-existent member: ${mirror.memberName}');
  }
}
{% endprettify %}

You can use the `@override` annotation to indicate that you are
intentionally overriding a member:

<!-- ch02/ch02_meta/bin/ch02_override.dart -->
{% prettify dart %}
class A {
  @override
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}
{% endprettify %}

If you use `noSuchMethod()` to implement every possible getter, setter,
and method for a class, then you can use the `@proxy` annotation to
avoid warnings:

<!-- ch02/ch02_meta/bin/ch02_proxy.dart -->
{% prettify dart %}
@proxy
class A {
  void noSuchMethod(Invocation mirror) {
    // ...
  }
}
{% endprettify %}

For more information on annotations, see
[Metadata](#metadata).


### Ajout de fonctionnalités à une classe: mixins {#adding-features-to-a-class-mixins}
{:.no_toc}

Les mixins sont une façon de réutiliser le code d'une classe dans des 
héritages multiples.

Pour utiliser un mixin, utilisez le mot-clé `with` suivi par un ou 
plusieurs noms de mixin. L'exemple suivant montre deux classes qui 
utilisent les mixins :

<!-- ch02/mixins.dart -->
{% prettify dart %}
class Musicien extends Interprete with Musical {
  // ...
}

class Maestro extends Personne with Musical, Aggressif, Dement {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}
{% endprettify %}

Pour implémenter un mixin, créez une classe qui étend d'Object, ne 
déclare pas de constructeurs, et n'a aucun appels à `super`. Par 
exemple:

<!-- ch02/mixins.dart -->
{% prettify dart %}
abstract class Musical {
  bool peutJouerDuPiano = false;
  bool peutComposer = false;
  bool peutConduire = false;

  void divertisMoi() {
    if (peutJouerDuPiano) {
      print('Joue du piano');
    } else if (peutComposer) {
      print('Bouge les mains');
    } else {
      print('Fredonne');
    }
  }
}
{% endprettify %}

Pour plus d'information, voir l'article [Mixins dans
Dart.](/articles/mixins/)


### Class variables and methods {#class-variables-and-methods}
{:.no_toc}

Use the `static` keyword to implement class-wide variables and methods.

#### Static variables {#static-variables}
{:.no_toc}

Static variables (class variables) are useful for class-wide state and
constants:

<!-- ch02/color.dart -->
{% prettify dart %}
class Color {
  static const red = const Color('red'); // A constant static variable.
  final String name;                     // An instance variable.
  const Color(this.name);                // A constant constructor.
}

main() {
  assert(Color.red.name == 'red');
}
{% endprettify %}

Static variables aren’t initialized until they’re used.

<aside class="alert alert-info" markdown="1">
**Note:**
This chapter follows the [style guide
recommendation](/articles/style-guide/#prefer-using-lowercamelcase-for-constant-names)
of preferring `lowerCamelCase` for constant names.
</aside>

#### Static methods {#static-methods}
{:.no_toc}

Static methods (class methods) do not operate on an instance, and thus
do not have access to `this`. For example:

<!-- ch02/point.dart -->
{% prettify dart %}
import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(distance < 2.9 && distance > 2.8);
}
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
Consider using top-level functions, instead of static methods, for
common or widely used utilities and functionality.
</aside>

You can use static methods as compile-time constants. For example, you
can pass a static method as a parameter to a constant constructor.


## Génériques {#generics}

Si vous regardez sur la documentation de l'API pour le type tableau de 
base, [List](http://api.dartlang.org/dart_core/List.html), vous verrez
que le type est en fait `List<E>`. La notation \<...\> marque la liste 
comme un type *générique* (ou *paramétré*), c'est-à-dire, un type qui 
prend des types en paramètre. Par convention, les variables de type ont
des noms d'une seule lettre, tels que E, T, S, K, et V.


### Pourquoi utiliser les génériques ? {#why-use-generics}
{:.no_toc}

Etant donné que les types sont optionnels en Dart, vous n'êtes *jamais 
obligé* d'utiliser les génériques. Il se peut que vous vouliez 
l'utiliser, pour la même raison que vous voudriez utiliser d'autres 
types dans votre code : les types (génériques ou non) vous permettent 
de documenter et d'annoter votre code, rendant votre intention plus 
claire.

Par exemple, si votre intention est qu'une liste ne contienne que des
chaînes de caractères, vous pouvez la déclarer comme `List<String>` (le 
lire comme “liste de string”). De cette façon, vous, vos co-programmeurs,
et vos outils (comme Dart Editor et la VM Dart en mode vérification) 
peuvent détecter qu'assigner autre chose qu'une chaîne de caractères à 
la liste est probablement une erreur. Voici un exemple :

<!-- ch02/generics.dart -->
{% prettify dart %}
var noms = new List<String>();
noms.addAll(['Seth', 'Kathy', 'Lars']);
// ...
noms.add(42); // Échoue en mode vérification (passe en mode production).
{% endprettify %}

Une autre raison pour utiliser les génériques est de réduire la 
duplication de code. Les génériques vous permettent de partager une 
seule interface et implémentation entre de nombreux types, tout en 
tirant avantage du mode vérification et des alertes préventives de 
l'analyse statique. Par exemple, disons que vous créez une interface
pour mettre en cache un objet :

<!-- ch02/generics.dart -->
{% prettify dart %}
abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}
{% endprettify %}

Vous découvrez que vous voulez une version spécifique de cette interface
pour les chaînes de caractères, donc vous créez une autre interface :

<!-- ch02/generics.dart -->
{% prettify dart %}
abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}
{% endprettify %}

Plus tard, vous décidez que vous voulez une version spécifique de cette 
interface pour les nombres... et ainsi de suite.

Les types génériques peuvent vous sauver de la difficulté de créer toutes
ces interfaces. A la place, vous pouvez créer une interface unique qui 
prend un type en paramètre :

<!-- ch02/generics.dart -->
{% prettify dart %}
abstract class Cache<T> {
  T getByKey(String key);
  setByKey(String key, T value);
}
{% endprettify %}

Dance ce code, T est un type de remplacement. C'est un paramètre fictif
que vous pensez comme un type qu'un développeur définira plus tard.


### En utilisant les collections littérales {#using-collection-literals}
{:.no_toc}

Les listes et les dictionnaires peut être paramétrés. Les valeurs
littérales paramétrées sont comme les valeurs littérales que vous avez
déjà vues, excepté que vous ajoutez
<code>&lt;<em>type</em>></code> pour les listes avant le crochet 
ouvrant ou
<code>&lt;<em>typeClé</em>, <em>typeValeur</em>></code> pour les 
dictionnaires avant l'accolade ouvrante. Vous pouvez utiliser les 
valeurs littérales paramétrées lorsque vous voulez des alertes de type
en mode vérification. Voici un exemple d'utilisation de valeurs 
littérales typées :

<!-- ch02/generics.dart -->
{% prettify dart %}
var noms = <String>['Seth', 'Kathy', 'Lars'];
var pages = <String, String>{
  'index.html': 'Accueil',
  'robots.txt': 'Trucs pour les robots',
  'humans.txt': 'Nous sommes des personnes, pas des machines'
};
{% endprettify %}


### En utilisant les types paramétrés avec les constructeurs {#using-parameterized-types-with-constructors}
{:.no_toc}

Pour spécifier un ou plusieurs types en utilisant un constructeur, 
mettre les types entre chevrons (`<...>`) juste après le nom de la 
classe. Par exemple :

<!-- ch02/generics.dart -->
{% prettify dart %}
var noms = new List<String>();
noms.addAll(['Seth', 'Kathy', 'Lars']);
var ensembleNoms = new Set<String>.from(noms);
{% endprettify %}

Le code suivant crée un dictionnaire qui a des entiers pour clé et des 
types Vue pour valeur :

<!-- ch02/generics.dart -->
{% prettify dart %}
var vues = new Map<int, Vue>();
{% endprettify %}


### Les collections génériques et les types qu'elles contiennent {#generic-collections-and-the-types-they-contain}
{:.no_toc}

Les types génériques Dart sont *réifiés*, c'est-à-dire qu'ils portent
l'information de leur type à l'exécution. Par exemple, vous pouvez 
tester le type d'une collection, même en mode production :

<!-- ch02/generics.dart -->
{% prettify dart %}
var noms = new List<String>();
noms.addAll(['Seth', 'Kathy', 'Lars']);
print(noms is List<String>); // true
{% endprettify %}

Cependant, l'expression `is` vérifie le type de la *collection* 
seulement, pas ceux des objets à l'intérieur. En mode production, une
`List<String>` peut avoir des éléments autres que des chaînes de 
caractères. La solution est de, soit vérifier le type de chaque élément
ou soit d'entourer le code manipulant les éléments dans un gestionnaire 
d'exception (voir [Exceptions](#exceptions)).

<aside class="alert alert-info" markdown="1">
**Note:**
En comparaison, les génériques en Java utilisent l'*effacement*, 
c'est-à-dire, que les paramètres d'un type générique sont enlevés à 
l'exécution. En Java, vous pouvez tester si un objet est une List, mais
vous ne pouvez pas tester si c'est une `List<String>`.
</aside>

Pour plus d'information sur les génériques, voir [Optional Types in
Dart.](/articles/optional-types/)


## Libraries and visibility {#libraries-and-visibility}

The `import`, `part`, and `library` directives can help you create a
modular and shareable code base. Libraries not only provide APIs, but
are a unit of privacy: identifiers that start with an underscore (\_)
are visible only inside the library. *Every Dart app is a library*, even
if it doesn’t use a library directive.

Libraries can be distributed using packages. See
[Pub Package and Asset Manager](/tools/pub/)
for information about
pub, a package manager included in the SDK.


### Using libraries {#using-libraries}
{:.no_toc}

Use `import` to specify how a namespace from one library is used in the
scope of another library.

For example, Dart web apps generally use the
[dart:html](http://api.dartlang.org/html.html) library, which they can
import like this:

<!-- ch02/libraries/using_libraries.dart -->
{% prettify dart %}
import 'dart:html';
{% endprettify %}

The only required argument to `import` is a URI specifying the
library.
For built-in libraries, the URI has the special `dart:` scheme.
For other libraries, you can use a file system path or the `package:`
scheme. The `package:` scheme specifies libraries provided by a package
manager such as the pub tool. For example:

<!-- ch02/libraries/using_schemes.dart, mylib, utils -->
{% prettify dart %}
import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
*URI* stands for uniform resource identifier.
*URLs* (uniform resource locators) are a common kind of URI.
</aside>


#### Specifying a library prefix {#specifying-a-library-prefix}
{:.no_toc}

If you import two libraries that have conflicting identifiers, then you
can specify a prefix for one or both libraries. For example, if library1
and library2 both have an Element class, then you might have code like
this:

<!-- ch02/libraries/library_prefix.dart, lib1, lib2 -->
{% prettify dart %}
import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.
{% endprettify %}

#### Importing only part of a library {#importing-only-part-of-a-library}
{:.no_toc}

If you want to use only part of a library, you can selectively import
the library. For example:

<!-- ch02/libraries/library_partil.dart, lib1, lib2 -->
{% prettify dart %}
import 'package:lib1/lib1.dart' show foo; // Import only foo.
import 'package:lib2/lib2.dart' hide foo; // Import all names EXCEPT foo.
{% endprettify %}


### Implementing libraries {#implementing-libraries}
{:.no_toc}

Use `library` to name a library, and `part` to specify additional files
in the library.

<aside class="alert alert-info" markdown="1">
**Note:**
You don’t have to use `library` in an app (a file that has a top-level
main() function), but doing so lets you implement the app in multiple
files.
</aside>

#### Declaring a library {#declaring-a-library}
{:.no_toc}

Use <code>library <em>identifier</em></code>
to specify the name of the current library:

<!-- ch02/ballgame.dart -->
{% prettify dart %}
library ballgame;   // Declare that this is a library named ballgame.

import 'dart:html'; // This app uses the HTML library.
// ...Code goes here...
{% endprettify %}

#### Associating a file with a library {#associating-a-file-with-a-library}
{:.no_toc}

To add an implementation file, put
<code>part <em>fileUri</em></code>
in the file that has the `library` statement, where *fileUri*
is the path to the implementation file. Then in the implementation file, put
<code>part of <em>identifier</em></code>,
where *identifier* is the name of the library. The following
example uses `part` and `part of` to implement a library in three files.

The first file, `ballgame.dart`, declares the ballgame library, imports
other libraries it needs, and specifies that `ball.dart` and `util.dart`
are parts of this library:

<!-- ch02/ballgame.dart -->
{% prettify dart %}
library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...
{% endprettify %}

The second file, `ball.dart`, implements part of the ballgame library:

<!-- ch02/ball.dart -->
{% prettify dart %}
part of ballgame;

// ...Code goes here...
{% endprettify %}

The third file, `util.dart`, implements the rest of the ballgame
library:

<!-- ch02/util.dart -->
{% prettify dart %}
part of ballgame;

// ...Code goes here...
{% endprettify %}

#### Re-exporting libraries {#re-exporting-libraries}
{:.no_toc}

You can combine or repackage libraries by re-exporting part or all of
them. For example, you might have a huge library that you implement as a
set of smaller libraries. Or you might create a library that provides a
subset of methods from another library.

<!-- ch02/french.dart, togo.dart, french_togo.dart -->
{% prettify dart %}
// In french.dart:
library french;

hello() => print('Bonjour!');
goodbye() => print('Au Revoir!');

// In togo.dart:
library togo;
import 'french.dart';
export 'french.dart' show hello;

// In another .dart file:
import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}
{% endprettify %}


## Isolates {#isolates}

Les navigateurs modernes, même sur les plateformes mobiles,
fonctionnent sur des processeurs multi-coeurs.
Pour tirer avantage de ces coeurs, les développeurs utilisent traditionnellement
des treads à mémoire partagée s'éxcutant en parrallèle.
Cependant, le parallélisme à état partagé est source d'erreur et
peut ammener à du code complexe.

Au lieu d'utiliser les threads, tout code Dart tourne au sein d'un *isolates*.
Chaque isolate possède sa propre mémoire tas, permettant de garantir qu'aucun état
d'isolate n'est accessible depuis un autre isolate.


## Typedefs {#typedefs}

En Dart, les fonctions sont des objets, tout comme les chaines de caractères
et les nombres sont des objets.
Un *typedef*, ou *alias de type de fonction*, donne un nom à un type de fonction
que vous pouvez utiliser pour déclarer un champ ou un type de retour.
Un typedef garde les informations de type lorsqu'un type de fonction est
assigné à une variable.

Voici un exemple de code qui n'utilise pas de typedef:

<!-- ch02/sorted_collection.dart -->
{% prettify dart %}
class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) => ... ; // Implémentation initiale erronée.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // Tout ce que nous savons est que compare est une fonction, mais quel type de fonction ?
  assert(collection.compare is Function);
}
{% endprettify %}

L'information de type est perdue lors de l'assignation de `f` à `compare`.
Le type de `f` est `(Object, ``Object)` → `int` (où → signigie retourne), le type de `compare`
est également Function. Si nous adaptons le code pour utiliser des noms explicites et garder l'information,
les développeurs ainsi que les outils peuvent utiliser cette information.

<!-- ch02/sorted_collection.dart -->
{% prettify dart %}
typedef int Compare(Object a, Object b);

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) => ... ; // Implémentation initial erronée.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}
{% endprettify %}

<aside class="alert alert-info" markdown="1">
**Note:**
Pour le moment, les typedefs sont cantonnés aux types de fonction. Cela
va certainement évoluer.
</aside>

Du fait que les typedefs sont des alias, ils offrent un moyen de vérifier le type de n'importe
quelle fonction. Par exemple :

<!-- ch02/sorted_collection.dart -->
{% prettify dart %}
typedef int Compare(int a, int b);

int sort(int a, int b) => a - b;

main() {
  assert(sort is Compare); // Vrai!
}
{% endprettify %}


## Metadata {#metadata}

Utilisez les metadata pour donner de l'information complémentaire à votre code.
Une annotation metadata commence par le caratère `@`, suivi par soit une référence
à une constante de compilation (telle que `deprecated`) soit un appel à un constructeur constant.

Trois annotations sont disponibles pour tout code Dart : `@deprecated`,
`@override`, et `@proxy`. Pour des exemples d'utilisation de `@override` et
`@proxy`, voir [Etendre une classe](#extending-a-class).
Voici un exemple d'utilisation de l'annotation `@deprecated` :

<!-- ch02/ch02_meta/bin/ch02_meta.dart -->
{% prettify dart %}
class Television {
  /// _Deprecated: Utiliser [allumer] à la place._
  @deprecated      // Metadata; fait en sorte que Dart Editor alerte sur l'utilisation de activate().
  void activer() {
    allumer();
  }

  /// Allume la télé.
  void allumer() {
    print('On!');
  }
}
{% endprettify %}

Vous pouvez définir vos propres annotations metadata. Voici un exemple de
définition de l'annotation @todo qui prend deux arguments :

<!-- ch02/ch02_meta_create/todo.dart -->
{% prettify dart %}
library todo;

class aFaire {
  final String qui;
  final String quoi;

  const aFaire(this.qui, this.quoi);
}
{% endprettify %}

Et voici un exemple d'utilisation de cette annotation @aFaire :

<!-- ch02/ch02_meta_create/metadata_user.dart -->
{% prettify dart %}
import 'todo.dart';

@todo('seth', 'Fait faire quelque chose à cette fonction')
void faitQuelqueChose() {
  print('Fait quelque chose');
}
{% endprettify %}

Les metadatas peuvent apparaitre avant une déclaration de librairie, classe, typedef, paramètre de type,
constructeur, factory, fonction, champ, paramètre, ou variable et avant un import ou export de directive.
Vous pouvez récupérer les metadatas durant l'execution en utilisant la réflexion.


## Commentaires {#comments}

Dart supporte les commentaires sur une ou plusieurs lignes et
les commentaires de documentation.


### Commentaires d'une ligne {#single-line-comments}
{:.no_toc}

Un commentaire d'une ligne commence par `//`. Tout entre `//` et la
fin de la ligne est ignoré par le compilateur Dart.

<!-- ch02/single_line_comments.dart -->
{% prettify dart %}
main() {
  // TODO: refactorer en AbstractLlamaGreetingFactory?
  print('Bienvenue à ma ferme de lamas !');
}
{% endprettify %}


### Commentaires de plusieurs lignes {#multi-line-comments}
{:.no_toc}

Un commentaire de plusieurs lignes commence par `/*` et se termine par `*/`.
Tout entre `/*` et `*/` est ignoré par le compilateur Dart (à moins que le commentaire ne soit un commentaire de documentation; voir la section suivante). Les commentaires de plusieurs lignes peuvent s'imbriquer.

<!-- ch02/multi_line_comments.dart -->
{% prettify dart %}
main() {
  /*
   * C'est beaucoup de travail. Envisager l'élevage de poulets.

  Llama larry = new Llama();
  larry.nourrir();
  larry.preparer();
  larry.nettoyer();
   */
}
{% endprettify %}


### Commentaires de documentation {#documentation-comments}
{:.no_toc}

Les commentaires de documentation sont des commentaires d'une ou plusieurs lignes qui commencent
avec `///` ou `/**`. Utiliser `///` sur plusieurs lignes consécutives a le même effet qu'un commentaire de documentation sur plusieurs lignes.

Dans un commentaire de documentation, le compilateur Dart ignore tout text sauf si celui-ci est entouré par des crochets.
En utilisant des crochets, vous pouvez référer à une classe, une méthode, un champ, une variable globale, une fonction et des paramètres. Les noms entre crochets sont résolues dans le champ lexical de l'élément documenté.

Voici un exemple de commentaires de documentation qui référencient d'autres classes et arguments:

<!-- ch02/doc_comments.dart -->
{% prettify dart %}
/// Une camélidé domestiqué d'amérique du sud (Lama glama).
///
/// Les cultures Andines utilisent les lamas comme nouriture et animaux de portage
/// depuis les temps préhistoriques.
class Lama {
  String nom;

  /// Nourris ton lama [Nourriture].
  ///
  /// Un lama typique mange une botte de foin par semaine.
  void nourrir(Nourriture nourriture) {
    // ...
  }

  /// Fait travailler ton lama sur une [activité] pour
  /// [limiteDeTemps] minutes.
  void travaille(Activité activité, int limiteDeTemps) {
    // ...
  }
}
{% endprettify %}

Dans la documentation générée, `[Nourriture]` devient un lien pour la documentation d'API pour la classe Nourriture.

Pour parser du code Dart et générer de la documentation HTML, vous pouvez utiliser the SDK [outil de génération de documentation.](/tools/docgen/) Pour un exemple de documentation générée, voir [Documentation API Dart.](http://api.dartlang.org)
Pour des conseils sur la struturation des commentaire, voir [Guide pour les commentaires de documentation Dart.](/articles/doc-comment-guidelines/)


## Résumé {#summary}

Ce chapitre résume les fonctionnalités les plus communes dans le langage
Dart. D'autres fonctionnalités sont en train d'être implémentées, et nous 
espérons qu'elles ne casseront pas le code existant. Pour plus 
d'information, voir la [Spécification du Langage Dart](/docs/spec/) et 
les [articles](/articles/) tel que [Idiomatic 
Dart.](/articles/idiomatic-dart/)


<hr>
{% include book-nav.html %}

